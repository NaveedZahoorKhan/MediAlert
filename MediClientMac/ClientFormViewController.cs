// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using AppKit;
using System.Threading;
using System.Net.Sockets;
using System.Text;
using System.Collections;
using System.Net;
using System.Runtime.InteropServices;
using System.IO;

namespace MediClientMac
{
	public partial class ClientFormViewController : NSViewController
	{
		public ClientFormViewController (IntPtr handle) : base (handle)
		{
			Thread thdListener = new Thread(new ThreadStart(listenerThread));
			thdListener.Start();
			int id = 0;     // The id of the hotkey. 
			Clients clt = GetLatestClient();
			if (clt != null)
			{
				if (!String.IsNullOrEmpty(clt.ModifierCode) && !String.IsNullOrEmpty(clt.KeyHashCode))
				{
					clt.LastHandle = RegisterKey(clt.ModifierCode, clt.KeyHashCode).ToString();
					WriteJsonFile(clt);
				}
			}

		}
		public ClientFormViewController()
		{
		}
		public void UnRegisterKey(IntPtr winHandle)
		{
			UnregisterHotKey(winHandle, 0);
		}

		string filename = "MediText.mdl";
		public const UInt32 SWP_NOSIZE = 0x0001;
		public const UInt32 SWP_NOMOVE = 0x0002;
		public const UInt32 TOPMOST_FLAGS = SWP_NOMOVE | SWP_NOSIZE;
		public const int WM_NCLBUTTONDOWN = 0xA1;
		public const int HT_CAPTION = 0x2;
		[DllImport("user32.dll")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, uint uFlags);

		[DllImportAttribute("user32.dll")]
		public static extern int SendMessage(IntPtr hWnd, int Msg, int wParam, int lParam);
		[DllImportAttribute("user32.dll")]
		public static extern bool ReleaseCapture();
		[DllImport("user32.dll")]
		public static extern IntPtr SetCapture(IntPtr hWnd);
		[DllImport("user32.dll")]
		public static extern bool RegisterHotKey(IntPtr hWnd, int id, int fsModifiers, int vk);
		[DllImport("user32.dll")]
		public static extern bool UnregisterHotKey(IntPtr hWnd, int id);
		[DllImport("user32.dll", EntryPoint = "FindWindow", SetLastError = true)]
		static extern IntPtr FindWindowByCaption(IntPtr ZeroOnly, string lpWindowName);
		[DllImport("user32.Dll")]
		static extern int PostMessage(IntPtr hWnd, UInt32 msg, int wParam, int lParam);
		const UInt32 WM_CLOSE = 0x0010;

		public void WriteJsonFile(Clients clt)
		{
			if (File.Exists(filename))
			{
				string fileData = FileHelper.ReadFileData(filename);
				string jsondata;
				if (String.IsNullOrEmpty(fileData))
				{
					jsondata = JsonHelper<Clients>.JsonSerializer(clt);
				}
				else
				{
					FileHelper.FlushFile(filename);
					jsondata = JsonHelper<Clients>.JsonSerializer(clt);
				}
				FileHelper.WriteFileData(filename, jsondata);
			}
			else
			{
				using (var stream = File.Create(filename)) { }
				string fileData = FileHelper.ReadFileData(filename);
				string jsondata;
				if (String.IsNullOrEmpty(fileData))
				{
					jsondata = JsonHelper<Clients>.JsonSerializer(clt);
				}
				else
				{
					FileHelper.FlushFile(filename);
					jsondata = JsonHelper<Clients>.JsonSerializer(clt);
				}
				FileHelper.WriteFileData(filename, jsondata);

			}
		}


		enum KeyModifier
		{
			None = 0,
			Alt = 1,
			Control = 2,
			Shift = 4,
			WinKey = 8
		};


		public static int icoCounter = 0;
		public void ClientThreadStart(MessageType mode)
		{

			Socket clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
			try
			{
				clientSocket.Connect(new IPEndPoint(IPAddress.Parse(ViewController.ServerIpAddress), 8001));

			}
			catch (SocketException ex)

			{
				if (clientSocket.Connected)
				{
					
					ModalRunner("Successfull Connected", ex.Message);
				
				}
				else
				{

					ModalRunner("Connection Failed to Server", ex.Message);
					
				}
				ModalRunner("Please start a server in order to send commands", ex.Message);
				return;
			}
			Clients clp = GetLatestClient();
			if (clp != null)
			{
				string message = "";
				if (mode == MessageType.Normal)
				{
					clp.ipadd = clientSocket.LocalEndPoint.ToString();
					if (clp.MessageMode == "Both")
					{
						if (icoCounter == 1 || icoCounter == 2)
						{

							clp.Message = clp.OkMessage;
						}
						else
							if (icoCounter == 0)
						{
							clp.Message = clp.AlertMessage;
						}
					}
					message = JsonHelper<Clients>.JsonSerializer(clp);
					clientSocket.Send(Encoding.ASCII.GetBytes(message));
				}
				else
					if (mode == MessageType.Connected)
				{
					clp.Message = "Client connected.";
					clp.ipadd = clientSocket.LocalEndPoint.ToString();
					clp.MessageMode = "Status";
					message = JsonHelper<Clients>.JsonSerializer(clp);
					clientSocket.Send(Encoding.ASCII.GetBytes(message));
				}
				else
						if (mode == MessageType.Disconnected)
				{
					clp.Message = "Client disconnected.";
					clp.ipadd = clientSocket.LocalEndPoint.ToString();
					clp.MessageMode = "Status";
					message = JsonHelper<Clients>.JsonSerializer(clp);
					clientSocket.Send(Encoding.ASCII.GetBytes(message));
				}
				else
							if (mode == MessageType.Acknowledge)
				{
					clp.Message = clp.ClientName + " Acknowledged.";
					clp.ipadd = clientSocket.LocalEndPoint.ToString();
					clp.MessageMode = "ACK";
					message = JsonHelper<Clients>.JsonSerializer(clp);
					clientSocket.Send(Encoding.ASCII.GetBytes(message));
				}

				//if (clp.MessageMode == "Alert")
				//{
				//    clientSocket.Send(Encoding.ASCII.GetBytes(message));
				//}
				//else
				//{
				//    clientSocket.Send(Encoding.ASCII.GetBytes(message));
				//}
			}
			else
			{
				ModalRunner("Please do save complete settings of client.", "Sorry no details found");
				
			}
			clientSocket.Close();
		}
		public void ModalRunner(string message, string infoText)
		{
			InvokeOnMainThread(() =>
					{

						NSAlert alert = new NSAlert();
						alert.MessageText = message;
						alert.InformativeText = "Reason: "+infoText;
						alert.AlertStyle = NSAlertStyle.Informational;
						alert.Icon = null;
						alert.RunModal();
					});
		}
		public Clients GetLatestClient()
		{
			Clients clt = new Clients();
			string fileData = FileHelper.ReadFileData(filename);
			if (!String.IsNullOrEmpty(fileData))
			{
				clt = JsonHelper<Clients>.JsonDeserialize(fileData);
				if (String.IsNullOrEmpty(clt.AlertMessage))
				{
					clt.AlertMessage = "Under Duress";
				}
				if (String.IsNullOrEmpty(clt.OkMessage))
				{
					clt.OkMessage = "No longer under Duress";
				}
			}
			else
			{
				clt = null;
			}
			return clt;
		}
		public enum MessageType
		{
			Normal,
			Connected,
			Disconnected,
			Acknowledge
		
		}
		public NSButton nSButton
		{
			get
			{
				return pictureBox1;
			}
			set
			{
				pictureBox1 = value;
			}
		}
		IPAddress ipAd = IPAddress.Parse(ViewController.IpAddressVal);
		private ArrayList nSockets = new ArrayList();
		partial void pictureBox1_actions(NSObject sender)
		{
			Console.WriteLine(sender.GetType());
			Thread t = new Thread(() => ClientThreadStart(MessageType.Normal));
			t.Start();
			if (icoCounter == 1 || icoCounter == 2)
			{
				pictureBox1.Image = new NSImage("green.ico");

				icoCounter = 0;

			}
			else
			{
				pictureBox1.Image = new NSImage("red.ico");
				//Program.gr.Close();
				//Program.re = new AlertOnRedClick();
				//Program.re.Show();
				icoCounter = 1;
			}
			pictureBox1.Activated += (s, e) =>
			{
				Console.WriteLine(((NSButton)s).Action);
			};
		}

		public void listenerThread()
		{
			try
			{
				TcpListener tcpListener = new TcpListener(ipAd, 8001);
				tcpListener.Start();
				while (true)
				{
					Socket handlerSocket = tcpListener.AcceptSocket();
					if (handlerSocket.Connected)
					{
						lock (this)
						{
							nSockets.Add(handlerSocket);
						}
						ThreadStart thdstHandler = new
						ThreadStart(handlerThread);
						Thread thdHandler = new Thread(thdstHandler);
						thdHandler.Start();
					}
				}
			}
			catch (Exception e)
			{
				Console.Write(e.Message);
			}
		}
	
		private static Thread workThread;
		public void handlerThread()
		{
			try
			{
				Socket handlerSocket = (Socket)nSockets[nSockets.Count - 1];
				NetworkStream networkStream = new NetworkStream(handlerSocket);
				int thisRead = 0;
				int blockSize = 1024;
				Byte[] dataByte = new Byte[blockSize];
				string fileData = null;
				lock (this)
				{
					while (true)
					{
						thisRead = networkStream.Read(dataByte, 0, blockSize);
						fileData = (Encoding.ASCII.GetString(dataByte)).Trim().Replace("\0", String.Empty);
						Clients clt = JsonHelper<Clients>.JsonDeserialize(fileData);
						if (clt.MessageMode == "Alert")
						{
							workThread = new Thread(() => ShowAcknowledge(clt.ClientName, clt.AlertMessage));
							workThread.Start();
						}
						else
							if (clt.MessageMode == "Both")
						{
							workThread = new Thread(() => ShowAcknowledge(clt.ClientName, clt.Message));
							workThread.Start();
						}
						else
								if (clt.MessageMode == "Status")
						{
							break;
						}
						else
								if (clt.MessageMode == "ACK")
						{
									pictureBox1.Image = new NSImage("amber.ico");
							icoCounter = 2;
							workThread = new Thread(() => CloseAcknowledge());
							workThread.Start();
						}
						else
						{
							workThread = new Thread(() => ShowAcknowledge(clt.ClientName, clt.OkMessage));
							workThread.Start();
						}
						break;
					}
				}
				handlerSocket = null;
			}
			catch
			{

			}
		}
		public void ShowAcknowledge(string clientName, string message)
		{
			
		}

		public void CloseAcknowledge()
		{
			
		}

	
		public string RegisterKey(string controlKey, string hashCodeKey)
		{
			int id = 0;     // The id of the hotkey. 
			IntPtr winHandle = this.Handle;
			int keymodifier = 0, keyHashCode = 0;
			switch (controlKey)
			{
				case "Control":
					keymodifier = (int)KeyModifier.Control;
					break;
				case "Alt":
					keymodifier = (int)KeyModifier.Alt;
					break;
				case "Shift":
					keymodifier = (int)KeyModifier.Shift;
					break;
				case "WinKey":
					keymodifier = (int)KeyModifier.WinKey;
					break;
				case "None":
					keymodifier = (int)KeyModifier.None;
					break;
				default:
					break;
			}

			switch (hashCodeKey)
			{
				case "A":
					keyHashCode = NSKey.A.GetHashCode();
					break;
				case "B":
					keyHashCode = NSKey.B.GetHashCode();
					break;
				case "C":
					keyHashCode = NSKey.C.GetHashCode();
					break;
				case "D":
					keyHashCode = NSKey.D.GetHashCode();
					break;
				case "E":
					keyHashCode = NSKey.E.GetHashCode();
					break;
				case "F":
					keyHashCode = NSKey.F.GetHashCode();
					break;
				case "G":
					keyHashCode = NSKey.G.GetHashCode();
					break;
				case "H":
					keyHashCode = NSKey.H.GetHashCode();
					break;
				case "I":
					keyHashCode = NSKey.I.GetHashCode();
					break;
				case "J":
					keyHashCode = NSKey.J.GetHashCode();
					break;
				case "K":
					keyHashCode = NSKey.K.GetHashCode();
					break;
				case "L":
					keyHashCode = NSKey.L.GetHashCode();
					break;
				case "M":
					keyHashCode = NSKey.M.GetHashCode();
					break;
				case "N":
					keyHashCode = NSKey.N.GetHashCode();
					break;
				case "O":
					keyHashCode = NSKey.O.GetHashCode();
					break;
				case "P":
					keyHashCode = NSKey.P.GetHashCode();
					break;
				case "Q":
					keyHashCode = NSKey.Q.GetHashCode();
					break;
				case "R":
					keyHashCode = NSKey.R.GetHashCode();
					break;
				case "S":
					keyHashCode = NSKey.S.GetHashCode();
					break;
				case "T":
					keyHashCode = NSKey.T.GetHashCode();
					break;
				case "U":
					keyHashCode = NSKey.U.GetHashCode();
					break;
				case "V":
					keyHashCode = NSKey.V.GetHashCode();
					break;
				case "W":
					keyHashCode = NSKey.W.GetHashCode();
					break;
				case "X":
					keyHashCode = NSKey.X.GetHashCode();
					break;
				case "Y":
					keyHashCode = NSKey.Y.GetHashCode();
					break;
				case "Z":
					keyHashCode = NSKey.Z.GetHashCode();
					break;
				case "F1":
					keyHashCode = NSKey.F1.GetHashCode();
					break;
				case "F2":
					keyHashCode = NSKey.F2.GetHashCode();
					break;
				case "F3":
					keyHashCode = NSKey.F3.GetHashCode();
					break;
				case "F4":
					keyHashCode = NSKey.F4.GetHashCode();
					break;
				case "F5":
					keyHashCode = NSKey.F5.GetHashCode();
					break;
				case "F6":
					keyHashCode = NSKey.F6.GetHashCode();
					break;
				case "F7":
					keyHashCode = NSKey.F7.GetHashCode();
					break;
				case "F8":
					keyHashCode = NSKey.F8.GetHashCode();
					break;
				case "F9":
					keyHashCode = NSKey.F9.GetHashCode();
					break;
				case "F10":
					keyHashCode = NSKey.F10.GetHashCode();
					break;
				case "F11":
					keyHashCode = NSKey.F11.GetHashCode();
					break;
				case "F12":
					keyHashCode = NSKey.F12.GetHashCode();
					break;
				default:
					break;
			}


			RegisterHotKey(winHandle, id, keymodifier, keyHashCode);

			return winHandle.ToString();
		}


	}

}
